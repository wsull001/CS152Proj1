Terminals unused in grammar

   FUNCTION
   BEGIN_PARAMS
   END_PARAMS
   BEGIN_LOCALS
   END_LOCALS
   BEGIN_BODY
   END_BODY
   INTEGER
   ARRAY
   OF
   IF
   THEN
   ENDIF
   ELSE
   WHILE
   DO
   BEGINLOOP
   ENDLOOP
   CONTINUE
   READ
   WRITE
   AND
   OR
   NOT
   TRUE
   FALSE
   RETURN
   SUB
   ADD
   DIV
   MOD
   EQ
   NEQ
   LT
   GT
   LTE
   GTE
   SEMICOLON
   COLON
   COMMA
   L_PAREN
   R_PAREN
   L_SQUARE_BRACKET
   R_SQUARE_BRACKET


Grammar

    0 $accept: input $end

    1 input: /* empty */
    2      | exp

    3 exp: INTEGER_LITERAL
    4    | exp PLUS exp
    5    | exp MULT exp


Terminals, with rules where they appear

$end (0) 0
error (256)
INTEGER_LITERAL (258) 3
FUNCTION (259)
BEGIN_PARAMS (260)
END_PARAMS (261)
BEGIN_LOCALS (262)
END_LOCALS (263)
BEGIN_BODY (264)
END_BODY (265)
INTEGER (266)
ARRAY (267)
OF (268)
IF (269)
THEN (270)
ENDIF (271)
ELSE (272)
WHILE (273)
DO (274)
BEGINLOOP (275)
ENDLOOP (276)
CONTINUE (277)
READ (278)
WRITE (279)
AND (280)
OR (281)
NOT (282)
TRUE (283)
FALSE (284)
RETURN (285)
SUB (286)
ADD (287)
MULT (288) 5
DIV (289)
MOD (290)
EQ (291)
NEQ (292)
LT (293)
GT (294)
LTE (295)
GTE (296)
SEMICOLON (297)
COLON (298)
COMMA (299)
L_PAREN (300)
R_PAREN (301)
L_SQUARE_BRACKET (302)
R_SQUARE_BRACKET (303)
PLUS (304) 4


Nonterminals, with rules where they appear

$accept (50)
    on left: 0
input (51)
    on left: 1 2, on right: 0
exp (52)
    on left: 3 4 5, on right: 2 4 5


State 0

    0 $accept: . input $end

    INTEGER_LITERAL  shift, and go to state 1

    $default  reduce using rule 1 (input)

    input  go to state 2
    exp    go to state 3


State 1

    3 exp: INTEGER_LITERAL .

    $default  reduce using rule 3 (exp)


State 2

    0 $accept: input . $end

    $end  shift, and go to state 4


State 3

    2 input: exp .
    4 exp: exp . PLUS exp
    5    | exp . MULT exp

    MULT  shift, and go to state 5
    PLUS  shift, and go to state 6

    $default  reduce using rule 2 (input)


State 4

    0 $accept: input $end .

    $default  accept


State 5

    5 exp: exp MULT . exp

    INTEGER_LITERAL  shift, and go to state 1

    exp  go to state 7


State 6

    4 exp: exp PLUS . exp

    INTEGER_LITERAL  shift, and go to state 1

    exp  go to state 8


State 7

    4 exp: exp . PLUS exp
    5    | exp . MULT exp
    5    | exp MULT exp .

    $default  reduce using rule 5 (exp)


State 8

    4 exp: exp . PLUS exp
    4    | exp PLUS exp .
    5    | exp . MULT exp

    MULT  shift, and go to state 5

    $default  reduce using rule 4 (exp)
